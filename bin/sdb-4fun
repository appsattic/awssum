#!/usr/bin/perl
##----------------------------------------------------------------------------

use strict;
use warnings;
use Data::Dumper;

use Getopt::Mixed "nextOption";
use Config::Simple;

use Amazon::AwsSum::Util qw(get_options vbs sep line cols errs force_array table);
use Amazon::AwsSum::SimpleDB;

## ----------------------------------------------------------------------------
# constants

use constant VERSION => '0.1';

my @IN_OPTS = (
    'a=s',   # attribute
    'i=s',   # item name
    'n=s',   # number
    't=s',   # token
    'd=s',   # domain name
    's=s',   # select expression
    'v=s',   # attribute value
    'r=s',   # replace
    'ap=s',  # attribute pair (of form 'key', 'key=value', '!key=value'
    'uuid',      'u>uuid',   # generate a uuid for this 'put'
    'confirm',   'c>confirm',   # confirm
    'file=s', # Config File to use
    'verbose',
    'help',
    'version',
);

my %BOOLEAN_ARGS = (
    uuid    => 1,
    confirm => 1,
    verbose => 1,
    help    => 1,
    version => 1,
);

use constant COMMANDS => {
    'add-dom' => 1,
    'del-dom' => 1,
    'list-dom' => 1,
    put => 1,
    del => 1,
    get => 1,
    select => 1,
    # batch-put-attributes
    # domain-metadata
};

## ----------------------------------------------------------------------------

# hmm, should get rid of this global
my $cfg = {};

MAIN: {
    my $args = get_options(\@IN_OPTS, \%BOOLEAN_ARGS);

    # setup the output things
    Amazon::AwsSum::Util::set_vbs( $args->{verbose} );

    # do the version and help
    if ( exists $args->{version} ) {
        print "$0 ".VERSION."\n";
        exit;
    }

    if ( exists $args->{help} ) {
        usage();
        exit;
    }

    line('Input Args');
    vbs( Dumper($args) );

    # make sure that the command given is valid
    Getopt::Mixed::abortMsg('specify a command')
       if @ARGV == 0;

    my $command = shift @ARGV;
    Getopt::Mixed::abortMsg('specify a valid command')
       unless defined $command and exists COMMANDS->{$command};

    # load the config
    Config::Simple->import_from( $args->{file} || "$ENV{HOME}/.awssum", $cfg );

    die 'specify an AWS Access Key ID [AwsAccessKeyId] in the config file'
        unless $cfg->{AwsAccessKeyId};
    die 'specify an AWS Secret Access Key [AwsSecretAccessKey] in the config file'
        unless $cfg->{AwsSecretAccessKey};

    line('Normal Output');

    my $sdb = Amazon::AwsSum::SimpleDB->new();
    $sdb->access_key_id( $cfg->{AwsAccessKeyId} );
    $sdb->secret_access_key( $cfg->{AwsSecretAccessKey} );

    # now call the relevant command
    if ( $command eq 'add-dom' ) {
        $sdb->CreateDomain({
            DomainName => $args->{d},
        });
        unless ( $sdb->errs ) {
            report_create_domain( $sdb->data );
        }
    }
    elsif ( $command eq 'list-dom' ) {
        $sdb->ListDomains({
            MaxNumberOfDomains => $args->{n},
            NextToken          => $args->{t},
        });
        unless ( $sdb->errs ) {
            report_list_domains( $sdb->data );
        }
    }
    elsif ( $command eq 'del-dom' ) {
        $sdb->DeleteDomain({
            DomainName => $args->{d},
        });
        unless ( $sdb->errs ) {
            report_delete_domain( $sdb->data );
        }
    }
    elsif ( $command eq 'put' ) {
        $sdb->PutAttributes({
            DomainName       => $args->{d},
            ItemName         => $args->{i},
            AttributeName    => $args->{a},
            AttributeValue   => $args->{v},
            AttributeReplace => $args->{r},
            AttributePair    => $args->{ap},
        });
        unless ( $sdb->errs ) {
            report_put_attributes( $sdb->data );
        }
    }
    elsif ( $command eq 'get' ) {
        $sdb->GetAttributes({
            DomainName    => $args->{d},
            ItemName      => $args->{i},
            AttributeName => $args->{a},
        });
        unless ( $sdb->errs ) {
            report_get_attributes( $sdb->data );
        }
    }
    elsif ( $command eq 'del' ) {
        $sdb->DeleteAttributes({
            DomainName     => $args->{d},
            ItemName       => $args->{i},
            AttributeName  => $args->{a},
            AttributeValue => $args->{v},
            AttributePair  => $args->{ap},
        });
        unless ( $sdb->errs ) {
            report_delete_attributes( $sdb->data );
        }
    }
    elsif ( $command eq 'select' ) {
        $sdb->Select({
            SelectExpression => $args->{s},
            NextToken        => $args->{t},
        });
        unless ( $sdb->errs ) {
            report_select( $sdb->data );
        }
    }

    if ( $sdb->errs ) {
        line('Request Errors');
        print errs( $sdb->errs );
    }

    line('HTTP Request');
    vbs( $sdb->http_request->method . " " . $sdb->http_request->uri );
    vbs( $sdb->http_request->headers_as_string( "\n" ) );
    line('HTTP Response');
    vbs( $sdb->http_response->code . ' ' . $sdb->http_response->message );
    vbs( $sdb->http_response->headers_as_string( "\n" ) );
    line('Content');
    vbs( $sdb->http_response->content );
    line('Data');
    vbs( Dumper( $sdb->data ));
    line();
}

## ----------------------------------------------------------------------------
# actions

sub report_create_domain {
    my ($data) = @_;
    print_metadata( $data );
}

sub report_list_domains {
    my ($data) = @_;
    print_metadata( $data );

    my (@cols, @rows);

    sep('Domain Names');
    force_array( $data->{ListDomainsResult}{DomainName} );
    @cols = ( qw(DomainName) );
    @rows = map { [ $_ ] } @{$data->{ListDomainsResult}{DomainName}};
    table( \@cols, @rows );
}

sub report_delete_domain {
    my ($data) = @_;
    print_metadata( $data );
}

sub report_put_attributes {
    my ($data) = @_;
    print_metadata( $data );
}

sub report_get_attributes {
    my ($data) = @_;
    print_metadata( $data );

    # output
    hdr( "# Attribute:\tName\tValue" );

    force_array( $data->{GetAttributesResult}{Attribute} );
    foreach my $a ( @{$data->{GetAttributesResult}{Attribute}} ) {
        print "Attribute:\t$a->{Name}\t$a->{Value}\n";
    }
}

sub report_delete_attributes {
    my ($data) = @_;
    print_metadata( $data );
}

sub report_select {
    my ($data) = @_;
    print_metadata( $data );

    # output
    # hdr( "# Item:\tItemName" );

    #force_array( $data->{SelectResult}{ItemName} );
    #foreach my $i ( @{$data->{SelectResult}{ItemName}} ) {
    #    print "Item:\t$i\n";
    #}

    my (@cols, @rows);

    sep('Items');
    force_array( $data->{SelectResult}{Item} );
    foreach my $item ( @{$data->{SelectResult}{Item}} ) {
        @cols = ( 'ItemName', map { $_->{Name} } @{$item->{Attribute}} );
        @rows = ( $item->{Name}, map { $_->{Value} } @{$item->{Attribute}} );
        table( \@cols, \@rows );
    }
}

# generic one
sub print_metadata {
    my ($data) = @_;

    #hdr( "# ResponseMetadata:\tRequestId\tBoxUsage" );
    #print "ResponseMetadata:\t$data->{ResponseMetadata}{RequestId}\t$data->{ResponseMetadata}{BoxUsage}\n";

    sep('Response MetaData');
    table(
        [ 'RequestId', 'BoxUsage' ],
        [ $data->{ResponseMetadata}{RequestId}, $data->{ResponseMetadata}{BoxUsage} ],
    );
}

## ----------------------------------------------------------------------------
# usage

sub usage {
   print <<"END_USAGE";
Usage: $0 <COMMAND>

Commands:
  list-dom [-n number] [-t token]
   * list domains
     -n number to list (1..100)
     -t next token to start from

  add-dom -d domain-name
   * add domain
     -d the domain name to add

  del-dom -d domain-name
   * delete a domain
     -d the domain name to delete

  put -d name -i name [-a attr] [-v value] [-r false|true] [--ap [!]attr=val]
   * put attributes
     -d domain name the item is in
     -i the item name to put these sttributes into
     -a the attribute name to put
     -v the value to put
     -r say whether this put is replace or not
     --ap attribute pair, of form attr=val or !attr=val (for replace)

  get -d name -i name [-a attr]
   * put attributes
     -d domain name the item is in
     -i the item name to put these sttributes into
     -a the attribute name to put (if none, then all attr)

  del -d name -i name [-a attr] [-v value] [-r 0|1] [--ap [!]attr=val]
   * put attributes
     -d domain name the item is in
     -i the item name to put these sttributes into
     -a the attribute name to put
     -v the value to put
     --ap attribute pair

  query -d name -q query [-n number] [-t token]
   * query a domain
     -d the domain name to query
     -q the query itself
     -n number to items to list
     -t next token to start from

See <http://github.com/andychilton/awssum/> for further information.
Report bugs to <andychilton -at- gmail -dot- com>.
END_USAGE
}

## ----------------------------------------------------------------------------
