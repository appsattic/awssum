#!/usr/bin/perl
##----------------------------------------------------------------------------

use strict;
use warnings;
use Data::Dumper;

use Getopt::Mixed "nextOption";
use Config::Simple;

use Amazon::AwsSum::Util qw(get_options vbs sep line errs force_array table);
use Amazon::AwsSum::SQS;

## ----------------------------------------------------------------------------
# constants

use constant VERSION => '0.1';

my @IN_OPTS = (
    'q=s',   # queue name
    't=s',   # timeout
    'p=s',   # queue name prefix
    'u=s',   # queue Url
    'a=s',   # attribute name
    'av=s',  # attribute value
    'm=s',   # message
    'r=s',   # receipt handle
    'n=s',   # number
    'file=s', # Config File to use
    'verbose',   'v>verbose',
    'help',
    'version',
);

my %BOOLEAN_ARGS = (
    verbose => 1,
    help    => 1,
    version => 1,
);

use constant COMMANDS => {
    'add-queue'       => 1, # CreateQueue
    'list-queues'     => 1, # ListQueues
    'get-queue-attrs' => 1, # GetQueueAttributes
    'set-queue-attrs' => 1, # SetQueueAttributes
    'del-queue'       => 1, # DeleteQueue
    'add-msg'         => 1, # SendMessage
    'get-msg'         => 1, # ReceiveMessage
    'del-msg'         => 1, # DeleteMesage
};

## ----------------------------------------------------------------------------

MAIN: {
    my $args = get_options(\@IN_OPTS, \%BOOLEAN_ARGS);

    # setup the output things
    Amazon::AwsSum::Util::set_vbs( $args->{verbose} );

    # do the version and help
    if ( exists $args->{version} ) {
        print "$0 ".VERSION."\n";
        exit;
    }

    if ( exists $args->{help} ) {
        usage();
        exit;
    }

    line('Input Args');
    vbs( Dumper($args) );

    # make sure that the command given is valid
    Getopt::Mixed::abortMsg('specify a command')
       if @ARGV == 0;

    my $command = shift @ARGV;
    Getopt::Mixed::abortMsg('specify a valid command')
       unless defined $command and exists COMMANDS->{$command};

    # load the config
    my $cfg = {};
    Config::Simple->import_from( $args->{file} || "$ENV{HOME}/.awssum", $cfg );

    die 'specify an AWS Access Key ID [AwsAccessKeyId] in the config file'
        unless $cfg->{AwsAccessKeyId};
    die 'specify an AWS Secret Access Key [AwsSecretAccessKey] in the config file'
        unless $cfg->{AwsSecretAccessKey};

    line('Normal Output');

    my $sqs = Amazon::AwsSum::SQS->new();
    $sqs->access_key_id( $cfg->{AwsAccessKeyId} );
    $sqs->secret_access_key( $cfg->{AwsSecretAccessKey} );

    # now call the relevant command
    if ( $command eq 'add-queue' ) {
        $sqs->CreateQueue({
            QueueName                => $args->{q},
            DefaultVisibilityTimeout => $args->{t},
        });
        create_queue( $sqs->data );
    }
    elsif ( $command eq 'list-queues' ) {
        $sqs->ListQueues({
            QueueNamePrefix => $args->{p},
        });
        unless ( $sqs->errs ) {
            list_queues( $sqs->data );
        }
    }
    elsif ( $command eq 'get-queue-attrs' ) {
        $sqs->GetQueueAttributes({
            QueueUrl      => $args->{u},
            AttributeName => $args->{a},
        });
        get_queue_attributes( $sqs->data )
            unless $sqs->errs;
    }
    elsif ( $command eq 'set-queue-attrs' ) {
        $sqs->SetQueueAttributes({
            QueueUrl       => $args->{u},
            AttributeName  => $args->{a},
            AttributeValue => $args->{av},
        });
        set_queue_attributes( $sqs->data )
            unless $sqs->errs;
    }
    elsif ( $command eq 'del-queue' ) {
        $sqs->DeleteQueue({
            QueueUrl => $args->{u},
        });
        delete_queue( $sqs->data );
    }
    elsif ( $command eq 'add-msg' ) {
        $sqs->SendMessage({
            QueueUrl    => $args->{u},
            MessageBody => $args->{m},
        });
        send_message( $sqs->data );
    }
    elsif ( $command eq 'get-msg' ) {
        $sqs->ReceiveMessage({
            QueueUrl            => $args->{u},
            MaxNumberOfMessages => $args->{n},
            VisibilityTimeout   => $args->{t},
        });
        receive_message( $sqs->data );
    }
    elsif ( $command eq 'del-msg' ) {
        $sqs->DeleteMessage({
            QueueUrl      => $args->{u},
            ReceiptHandle => $args->{r},
        });
        delete_message( $sqs->data );
    }

    if ( $sqs->errs ) {
        line('Request Errors');
        print errs( $sqs->errs );
    }

    line('HTTP Request');
    vbs( $sqs->http_request->method . " " . $sqs->http_request->uri );
    vbs( $sqs->http_request->headers_as_string( "\n" ) );
    line('HTTP Request Content');
    vbs( $sqs->http_request->content );
    line('HTTP Response');
    vbs( $sqs->http_response->code . ' ' . $sqs->http_response->message );
    vbs( $sqs->http_response->headers_as_string( "\n" ) );
    line('HTTP Response Content');
    vbs( $sqs->http_response->content );
    line('Data');
    vbs( Dumper( $sqs->data ));
    line();
}

## ----------------------------------------------------------------------------
# reports

sub create_queue {
    my ($data) = @_;
    print_metadata($data);

    my (@cols, @rows);

    sep('Queue');
    @cols = ( qw(QueueURL) );
    $rows[0] = [ $data->{CreateQueueResult}{QueueUrl} ];
    table( \@cols, @rows );
}

sub list_queues {
    my ($data) = @_;
    print_metadata($data);

    my (@cols, @rows);

    sep('Queue URLs');
    @cols = ( qw(QueueUrl) );
    @rows = map { [ $_ ] } @{$data->{ListQueuesResult}{QueueUrl}};
    table( \@cols, @rows );

    sep('Distribution Summary');
    force_array( $data->{DistributionSummary} );
    @cols = ( qw(Id Status Enabled Origin DomainName LastModifiedTime) );
    @rows = map { [ @$_{ @cols } ] } @{$data->{DistributionSummary}};
    table( \@cols, @rows );
}

sub get_queue_attributes {
    my ($data) = @_;
    print_metadata($data);

    my (@cols, @rows);

    sep('Queue Attributes');
    @cols = ( 'Attribute Name', 'Attribute Value' );
    @rows = map { [ $_->{Name}, $_->{Value} ] } sort { $a->{Name} cmp $b->{Name} } @{$data->{GetQueueAttributesResult}{Attribute}};

    table( \@cols, @rows );
}

sub set_queue_attributes {
    my ($data) = @_;
    print_metadata($data);
}

sub delete_queue {
    my ($data) = @_;
    print_metadata($data);
}

sub send_message {
    my ($data) = @_;
    print_metadata($data);

    my (@cols, @rows);

    sep('Receive Message Result');
    @cols = ( qw(MessageId MD5OfMessageBody) );
    $rows[0] = [ @{$data->{SendMessageResult}}{@cols} ];
    table( \@cols, @rows );
}

sub receive_message {
    my ($data) = @_;
    print_metadata($data);

    my (@cols, @rows);

    sep('Receive Message Result');
    force_array( $data->{ReceiveMessageResult}{Message} );
    @cols = ( qw(MessageId ReceiptHandle MD5OfBody Body) );
    @rows = map { [ @$_{ @cols } ] } @{$data->{ReceiveMessageResult}{Message}};
    table( \@cols, @rows );
}

sub delete_message {
    my ($data) = @_;
    print_metadata($data);
}

# generic one
sub print_metadata {
    my ($data) = @_;

    sep('Response MetaData');
    table(
        [ 'RequestId' ],
        [ $data->{ResponseMetadata}{RequestId} ],
    );

}

## ----------------------------------------------------------------------------
# usage

sub usage {
   print <<"END_USAGE";
Usage: $0 <COMMAND>

Commands:
  add-queue -q QueueName [-t DefaultVisibilityTimeout]
   * create queue
     -q the queue name
     -t the default visibility timeout in secs (default: 30)

  list-queues [-p QueueNamePrefix]
   * list queues
     -p a prefix used to filter the list

  get-queue-attrs -u URL -a All|ApproximateNumberOfMessages|VisibilityTimeout...
   * get queue attributes
     -u the queue URL you were returned using the CreateQueue command
     -a one of the above three values

  set-queue-attrs -a [VisibilityTimeout|Policy] --av Value
   * set queue attributes
     --av a Name=Value pair (Name must be 'VisibilityTimeout'

  del-queue -u QueueUrl
   * delete queue
     -u the queue URL you were returned using the CreateQueue command

  add-msg -u QueueUrl -m Message
   * Send a Message to the queue
     -u the queue URL you were returned using the CreateQueue command

  get-msg -u QueueUrl -n MaxNumberOfMessages -t VisibilityTimeout
   * receive one or more messages from the queue
     -u the queue URL you were returned using the CreateQueue command
     -n the number of messages to receive (1-10)
     -t the timeout to use with these messages (overrides the queue default)

  del-msg -u QueueUrl -r ReceiptHandle
   * delete a message from the queue
     -u the queue URL you were returned using the CreateQueue command
     -r the receipt handle you were given when receiving messages

Note: for all '-u' options, SQS requires you to use the full URL for certain
operations. The documentation states that you should store the entire queue URL
returned when the queue was created and that you use it when necessary. It also
states that you should not build the URL [from the queue name and the SQS base
URL] because SQS may change the components that make up the Queue Url.

See <http://github.com/andychilton/awssum/> for further information.
Report bugs to <andychilton -at- gmail -dot- com>.
END_USAGE
}

## ----------------------------------------------------------------------------
