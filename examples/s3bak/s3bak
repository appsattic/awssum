#!/usr/bin/perl
## -------------------------------------------------------------------*-perl-*-
#
# The following notice applies only to the main program 's3bak'.
#
# Copyright (c) 2005-2008 Andrew Chilton <andychilton@gmail.com>
#
# This code is hereby licensed for public consumption under either the
# GNU GPL v2 or greater, or Larry Wall's Artistic license - your choice.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
## ----------------------------------------------------------------------------

use strict;
use warnings;
use Carp;
use Data::Dumper;
use Log::TraceMessages qw(t d);
use Getopt::Mixed "nextOption";
use Config::Simple;
use MIME::Types;
use XML::Simple;
use File::Slurp;
use File::Find ();
use File::Basename;
use Digest::MD5 qw(md5_hex);

use Amazon::AwsSum::S3;

$Log::TraceMessages::On = 0;

use constant VERSION => '0.1';

## ----------------------------------------------------------------------------

my @IN_OPTS = qw(
                  bucket=s b>bucket
                  prefix=s p>prefix
                  acl=s    a>acl
                  force    f>force
                  test     t>test
                  verbose  v>verbose
                  debug    d>debug
                  help
                  version
);

use constant BOOLEAN_ARGS => {
    force   => 1,
    test    => 1,
    verbose => 1,
    debug   => 1,
    help    => 1,
    version => 1
};

use constant COMMANDS => {
    create   => 1,
    buckets  => 1,
    remove   => 1,
    contents => 1,
    put      => 1,
    get      => 1,
    del      => 1,
    bakup    => 1,
    bakdown  => 1,
    diff     => 1,
};

## ----------------------------------------------------------------------------

MAIN: {
    my $args = {};
    Getopt::Mixed::init( @IN_OPTS );
    while( my($opt, $val, $pretty) = nextOption() ) {
        $args->{$opt} = exists BOOLEAN_ARGS->{$opt} ? 1 : $val;
    }
    Getopt::Mixed::cleanup();

    $Log::TraceMessages::On = 1 if $args->{debug};
    set_verbose( $args->{verbose} );

    t "Check for 'version' and 'help'";

    # do the version and help
    if ( exists $args->{version} ) {
        print "$0 ".VERSION."\n";
        exit;
    }

    if ( exists $args->{help} ) {
        usage();
        exit;
    }

    # make sure that the command given is valid
    Getopt::Mixed::abortMsg('specify a command')
       if @ARGV == 0;

    my $command = shift @ARGV;
    Getopt::Mixed::abortMsg('specify a valid command')
       unless defined $command and exists COMMANDS->{$command};

    # get the config information
    t "Load the config";
    my $cfg = {};
    Config::Simple->import_from( config_filename(), $cfg );

    # now check we have everything we need
    t "Check we have an 'Access Key ID' and a 'Secret Access Key'";
    Getopt::Mixed::abortMsg('specify an AWS Access Key ID [AwsAccessKeyId] in the config file')
       unless $cfg->{AwsAccessKeyId};
    Getopt::Mixed::abortMsg('specify an AWS Secret Access Key [AwsSecretAccessKey] in the config file')
       unless $cfg->{AwsSecretAccessKey};

    # now we are here, we should make the connection object (doesn't _actually_ connect)
    t "Make the connection object";
    my $s3 = Amazon::AwsSum::S3->new();
    $s3->access_key_id( $cfg->{AwsAccessKeyId} );
    $s3->secret_access_key( $cfg->{AwsSecretAccessKey} );


    # check that we have a bucket name for certain commands
    if ( $command ne 'buckets' ) {
        t "Check we have a bucket name to use";
        Getopt::Mixed::abortMsg("specify a bucket for this command")
           unless (exists $args->{bucket} || $cfg->{BucketDefault});
    }

    # now call the relevant command
    if ( $command eq 'create' ) {
        t "Create a new bucket";
        create( $s3, $args->{bucket}, $args->{location} );

    }
    elsif ( $command eq 'buckets' ) {
        t "List all buckets";
        buckets( $s3 );

    }
    elsif ( $command eq 'remove' ) {
        t "Remove this bucket";
        remove( $s3, $args->{bucket} );

    }
    elsif ( $command eq 'contents' ) {
        t "List bucket contents";
        contents( $s3, $args->{bucket} || $cfg->{BucketDefault}, $args->{prefix} );

    }
    elsif ( $command eq 'put' ) {
        t "Put a file";
        my @filenames = @ARGV;
        put( $s3, $args->{bucket} || $cfg->{BucketDefault}, $args->{acl}, \@filenames );

    }
    elsif ( $command eq 'get' ) {
        t "Get these files";
        my @filenames = @ARGV;
        get( $s3, $args->{bucket} || $cfg->{BucketDefault}, \@filenames );

    }
    elsif ( $command eq 'del' ) {
        t "Deleting keys from a bucket";
        my @filenames = @ARGV;
        del( $s3, $args->{bucket} || $cfg->{BucketDefault}, \@filenames );

    }
    elsif ( $command eq 'del-using-prefix' ) {
        t "Deleting keys from a bucket using a prefix";
        del_using_prefix( $s3, $args->{bucket} || $cfg->{BucketDefault}, $args->{prefix} );

    }
    elsif ( $command eq 'bakup' ) {
        t "Backup all these local files to S3";
        my @filenames = @ARGV;
        bakup( $s3, $args->{bucket} || $cfg->{BucketDefault}, $args->{force}, \@filenames, $args->{test} );

    }
    elsif ( $command eq 'bakdown' ) {
        t "Retrieving any locally unknown files from S3";
        bakdown( $s3, $args->{bucket} || $cfg->{BucketDefault}, $args->{force}, $args->{prefix}, $args->{test} );

    }
    elsif ( $command eq 'diff' ) {
        t "Performs a diff between local and the bucket";
        diff( $s3, $args->{bucket} || $cfg->{BucketDefault}, $args->{prefix} );

    }
    else {
        print STDERR "Program Error: command unrecognised";
    }

    exit;
}

## ----------------------------------------------------------------------------
# commands

sub create {
    my ($s3, $bucket, $location) = @_;

    $s3->CreateBucket({
        Bucket             => $bucket,
        LocationConstraint => $location,
    });
    if ( $s3->errs ) {
        print_error_code( $s3->data );
        exit 2;
    }
}

sub buckets {
    my ($s3) = @_;

    $s3->ListBuckets();
    if ( $s3->errs ) {
        print_error_code( $s3->data );
        exit 2;
    }

    my $data = $s3->data;
    foreach my $bucket ( @{$data->{Buckets}{Bucket}} ) {
        print "$bucket->{CreationDate}   $bucket->{Name}\n";
    }
}

sub remove {
    my ($s3, $bucket) = @_;

    $s3->DeleteBucket({
        Bucket => $bucket,
    });
    if ( $s3->errs ) {
        print_error_code( $s3->data );
        exit 2;
    }
}

sub contents {
    my ($s3, $bucket, $prefix) = @_;

    my $contents = get_contents($s3, $bucket, $prefix);

    foreach ( @$contents ) {
        print "$_->{LastModified}   $_->{ETag}   '$_->{Key}' ($_->{Size})\n";
    }
}

sub put {
    my ($s3, $bucket, $acl, $keys) = @_;
    foreach my $key ( @$keys ) {
        put_object($s3, $bucket, $acl, $key);
    }
}

sub get {
    my ($s3, $bucket, $keys) = @_;

    foreach my $key ( @$keys ) {
        get_object($s3, $bucket, $key);
    }
}

sub del_using_prefix {
    my ($s3, $bucket, $prefix) = @_;

    my $keys = get_keys($s3, $bucket, $prefix);
    foreach my $key ( @$keys ) {
        del_object($s3, $bucket, $key);
    }
}

sub del {
    my ($s3, $bucket, $keys) = @_;
    foreach my $key ( @$keys ) {
        del_object($s3, $bucket, $key);
    }
}

sub bakup {
    my ($s3, $bucket, $force, $filenames, $test) = @_;

    my $keys = get_keys($s3, $bucket);
    t "s3_files = " . d($keys);

    my $s3_keys = {};
    $s3_keys->{$_} = 1 foreach @$keys;

    # only upload the keys which don't exist
    foreach my $filename ( @$filenames ) {
        t "Seeing if '$filename' exists in S3";
        if ( !$force and exists $s3_keys->{$filename} ) {
            print "Exists: $filename (use -f to force overwrite)\n";
            next;
        }

        if ( $test ) {
            print "Uploading: $filename (skipping)\n";
            next;
        }

        put_object($s3, $bucket, undef, $filename);
    }
}

sub bakdown {
    my ($s3, $bucket, $force, $prefix, $test) = @_;

    my $keys = get_keys($s3, $bucket);
    t "s3_files = " . d($keys);

    # download all files from S3
    foreach my $key ( @$keys ) {
        t "Seeing if '$key' exists locally";
        if ( !$force and -f $key ) {
            print "Exists: $key (use -f to force overwrite)\n";
            next;
        }

        # get the parts of the filename
        my ($name, $path) = fileparse($key);

        system('mkdir', '-p', $path) == 0
            or die "system failed: $?";

        if ( $test ) {
            print "Getting: $key (skipping)\n";
            next;
        }

        get_object($s3, $bucket, $key);
    }
}

sub diff {
    my ($s3, $bucket, $prefix) = @_;

    my $prefix_length = length $prefix;

    my $contents = get_contents($s3, $bucket, $prefix);
    t "contents = " . d($contents);

    my $s3_keys = {};
    $s3_keys->{$_->{Key}} = $_ foreach @$contents;
    t "s3_keys = " . d($s3_keys);

    my $filenames = get_local_filenames();

    # loop through all the local files
    foreach my $filename ( @$filenames ) {
        $filename =~ s{ \A \. \/ }{}xms;

        my $this_prefix = substr($filename, 0, $prefix_length);

        t "Skipping if it doesn't start with prefix";
        next if $this_prefix ne $prefix;

        t "Skipping if '$filename' is a symlink";
        next if -l $filename;

        t "Seeing if '$filename' exists and is a regular file";
        next unless -f $filename;

        t "Seeing if '$filename' exists in S3";
        if ( exists $s3_keys->{$filename} ) {
            my $digest = md5_hex(read_file($filename));
            if ( $digest ne $s3_keys->{$filename}{ETag} ) {
                print "Differs: $filename\n";
            }
        }
        else {
            print "Put: $filename\n";
        }
    }

    # loop through all the remote keys
    foreach my $key ( sort keys %$s3_keys ) {
        if ( -f $key ) {
            my $digest = md5_hex(read_file($key));
            if ( $digest ne $s3_keys->{$key}{ETag} ) {
                print "Differs: $key\n";
            }
        }
        else {
            print "Get: $key\n";
        }
    }
}

## ----------------------------------------------------------------------------
# helpful S3 utility functions

sub get_contents {
    my ($s3, $bucket, $prefix) = @_;

    my $marker;

    my @contents;
    my $complete = 0;

    # keep doing this until complete
    until ( $complete ) {
        $s3->ListKeys({
            Bucket => $bucket,
            Prefix => $prefix,
            Marker => $marker,
        });

        if ( $s3->errs ) {
            print_error_code( $s3->data );
            exit 2;
        }

        my $data = $s3->data;
        if ( ref $data->{Contents} eq 'HASH' ) {
            $data->{Contents} = [ $data->{Contents} ];
        }
        foreach my $entry ( @{$data->{Contents}} ) {
            $entry->{ETag} =~ s{ \A \" }{}gxms;
            $entry->{ETag} =~ s{ \" \z }{}gxms;
            push @contents, $entry;
        }

        # check to see if we are complete
        if ( $data->{IsTruncated} eq 'true' ) {
            # set the last one we just did
            $marker = $data->{Contents}[-1]{Key};
        }
        else {
            $complete = 1;
        }
    }
    return \@contents;
}

sub get_keys {
    my ($s3, $bucket, $prefix) = @_;

    my $contents = get_contents($s3, $bucket, $prefix);
    my @keys = map { $_->{Key} } @$contents;
    return \@keys;
}

sub put_object {
    my ($s3, $bucket, $acl, $key) = @_;

    t "put_object():";
    t "  bucket   = $bucket";
    t "  acl      = " . (defined $acl ? $acl : '[undef]');
    t "  key      = $key";

    # do some initial figuring out
    my ($ext) = $key =~ m{ \. (.*) \z }xms;
    my $mimetype = MIME::Types->new()->mimeTypeOf($ext);

    t "  ext      = " . ($ext || '[undef]');
    t "  mimetype = " . ($mimetype || '[undef]');

    my $content = read_file( $key );

    # now do the upload
    print "Uploading: $key\n";

    $s3->PutObject({
        Bucket  => $bucket,
        Key     => $key,
        defined $acl ? (Acl => $acl) : (),
        defined $mimetype ? (headers => { 'Content-Type' => $mimetype }) : (),
        content => $content,
    });
    if ( $s3->errs ) {
        print_error_code( $s3->data );
        exit 2;
    }
}

sub get_object {
    my ($s3, $bucket, $key) = @_;

    # get the parts of the key/filename
    my ($name, $path) = fileparse($key);

    system('mkdir', '-p', $path) == 0
        or die "system failed: $?";

    print "Getting: $key\n";

    $s3->GetObject({
        Bucket => $bucket,
        Key    => $key,
    });
    if ( $s3->errs ) {
        print_error_code( $s3->data );
        exit 2;
    }

    write_file( $key, $s3->http_response->content );
}

sub del_object {
    my ($s3, $bucket, $key) = @_;

    print "Deleting: $key\n";
    $s3->DeleteObject({
        Bucket => $bucket,
        Key    => $key,
    });
    if ( $s3->errs ) {
        print_error_code( $s3->data );
        exit 2;
    }
}

sub print_error_code {
    my ($data) = @_;
    print STDERR "Error: $data->{Code} - $data->{Message}\n";
}

## ----------------------------------------------------------------------------

sub get_local_filenames {
    my $filenames = [];
    File::Find::find({
        wanted => sub {
            my ($dev,$ino,$mode,$nlink,$uid,$gid);
            (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_))
                && -f $_
                && push @$filenames, $File::Find::name;
        }
    }, '.');
    return $filenames;
}

sub config_filename {
    my $filename = "~/.awssum";
    # from Recipe 7.3
    $filename =~ s{ ^ ~ ( [^/]* ) }{
        $1 ? (getpwnam($1))[7]
           : ( $ENV{HOME} || $ENV{LOGDIR}
               || (getpwuid($>))[7] )
       }ex;
    t "Config filename = '$filename'";
    return $filename;
}

sub usage {
   print <<"END_USAGE";
Usage: $0 command [-b bucket] [-f] [-a acl] [files...]

Commands:
  create -b bucket
    - create a new bucket

  buckets
    - lists all of your buckets

  remove -b bucket
    - removes the named bucket

  contents [-b bucket] -p prefix
    - lists all keys in a bucket
    - if no bucket specified, tries to use BucketDefault from the config

  put [-b bucket] [-a acl] filenames...
    - unconditionally puts files to S3
    - if no bucket specified, tries to use BucketDefault from the config

  get [-b bucket] filenames...
    - unconditionally gets files from S3
    - if no bucket specified, tries to use BucketDefault from the config

  del [-b bucket] filenames...
    - unconditionally deletes files in S3
    - if no bucket specified, tries to use BucketDefault from the config

  bakup [-f] [-t] [-b bucket] filenames...
   - uploads all local files which do not exist in S3
    - if no bucket specified, tries to use BucketDefault from the config
   (use -f to force a file up if it exists in S3)

  bakdown [-f] [-t] [-b bucket] [-p prefix]
   - downloads all S3 files which do not exist locally
    - if no bucket specified, tries to use BucketDefault from the config
   (use -f to force a file down if it exists locally)

  diff [-b bucket] [-p prefix]
   - performs and reports a diff between S3 and local
    - if no bucket specified, tries to use BucketDefault from the config

Options:
  -b, --bucket bucket      the bucket to use for this operation
  -f, --force              forces s3bak to do something it would not usually do
  -a, --acl                either 'public-read' or 'public-write'
  -v, --verbose            turns on verbose
      --help               prints help then quits
      --version            prints version information then quits

See <http://github.com/andychilton/awssum/> for further information.
Report bugs to <andychilton -at- gmail -dot- com>.
END_USAGE
}

{
    my $VERBOSE;
    sub set_verbose { $VERBOSE = $_[0] }
    sub v { print @_, "\n" if $VERBOSE }
}

## ----------------------------------------------------------------------------
